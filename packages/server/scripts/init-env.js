const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const dotenv = require('dotenv');

/**
 * Initialize .env file with secure JWT secret and other required variables
 * This script generates a cryptographically secure JWT secret if not already present
 */

const ENV_PATH = path.join(__dirname, '..', '.env');
const ENV_EXAMPLE_PATH = path.join(__dirname, '..', '.env.example');

/**
 * Generate a cryptographically secure JWT secret
 * Uses 64 bytes (512 bits) of random data, base64 encoded
 */
function generateJWTSecret() {
  return crypto.randomBytes(64).toString('base64');
}

/**
 * Generate a secure session secret (32 bytes, hex encoded)
 */
function generateSessionSecret() {
  return crypto.randomBytes(32).toString('hex');
}

/**
 * Parse .env file content into key-value pairs
 */
function parseEnvFile(content) {
  const env = {};
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith('#')) {
      const [key, ...valueParts] = trimmed.split('=');
      if (key && valueParts.length > 0) {
        env[key] = valueParts.join('=');
      }
    }
  }
  
  return env;
}

/**
 * Convert environment object back to .env file format
 */
function stringifyEnvFile(env, includeComments = true) {
  let content = '';
  
  if (includeComments) {
    content += '# Server Environment Variables\n';
    content += '# Generated by init-env script\n';
    content += `# Generated at: ${new Date().toISOString()}\n\n`;
  }
  
  // Group environment variables by category
  const categories = {
    'Server Configuration': ['PORT', 'NODE_ENV'],
    'Database Configuration': ['DB_HOST', 'DB_PORT', 'DB_USER', 'DB_PASSWORD', 'DB_NAME'],
    'Security': ['JWT_SECRET', 'JWT_EXPIRES_IN', 'SESSION_SECRET'],
    'Telegram Bot Configuration': ['TELEGRAM_BOT_TOKEN']
  };
  
  for (const [category, keys] of Object.entries(categories)) {
    if (includeComments) {
      content += `# ${category}\n`;
    }
    
    for (const key of keys) {
      if (env[key] !== undefined) {
        content += `${key}=${env[key]}\n`;
      }
    }
    
    content += '\n';
  }
  
  // Add any remaining keys not in categories
  const categorizedKeys = Object.values(categories).flat();
  for (const [key, value] of Object.entries(env)) {
    if (!categorizedKeys.includes(key)) {
      content += `${key}=${value}\n`;
    }
  }
  
  return content.trim() + '\n';
}

/**
 * Check if JWT secret is secure (not a placeholder)
 */
function isSecureJWTSecret(secret) {
  if (!secret) return false;
  
  const insecurePatterns = [
    'your_jwt_secret_key_here',
    'jwt_secret',
    'secret',
    'password',
    '123456',
    'test'
  ];
  
  const lowerSecret = secret.toLowerCase();
  return !insecurePatterns.some(pattern => lowerSecret.includes(pattern)) && secret.length >= 32;
}

/**
 * Main initialization function
 */
async function initEnv() {
  console.log('üîê Initializing environment configuration...');
  
  let env = {};
  let envExists = false;
  
  // Check if .env file already exists
  if (fs.existsSync(ENV_PATH)) {
    console.log('üìÑ Found existing .env file');
    const existingContent = fs.readFileSync(ENV_PATH, 'utf8');
    env = parseEnvFile(existingContent);
    envExists = true;
  } else if (fs.existsSync(ENV_EXAMPLE_PATH)) {
    console.log('üìã Using .env.example as template');
    const exampleContent = fs.readFileSync(ENV_EXAMPLE_PATH, 'utf8');
    env = parseEnvFile(exampleContent);
  } else {
    console.log('üÜï Creating new .env configuration');
    // Default configuration
    env = {
      PORT: '3000',
      NODE_ENV: 'development',
      DB_HOST: 'localhost',
      DB_PORT: '5432',
      DB_USER: 'postgres',
      DB_PASSWORD: 'postgres',
      DB_NAME: 'match3',
      JWT_EXPIRES_IN: '7d',
      TELEGRAM_BOT_TOKEN: 'your_telegram_bot_token_here'
    };
  }
  
  let updated = false;
  
  // Generate JWT secret if not present or insecure
  if (!env.JWT_SECRET || !isSecureJWTSecret(env.JWT_SECRET)) {
    const newSecret = generateJWTSecret();
    console.log('üîë Generating secure JWT secret...');
    env.JWT_SECRET = newSecret;
    updated = true;
  } else {
    console.log('‚úÖ JWT secret already configured and secure');
  }
  
  // Generate session secret if not present
  if (!env.SESSION_SECRET) {
    const sessionSecret = generateSessionSecret();
    console.log('üõ°Ô∏è  Generating session secret...');
    env.SESSION_SECRET = sessionSecret;
    updated = true;
  }
  
  // Ensure required fields have default values
  const defaults = {
    PORT: '3000',
    NODE_ENV: 'development',
    JWT_EXPIRES_IN: '7d'
  };
  
  for (const [key, defaultValue] of Object.entries(defaults)) {
    if (!env[key]) {
      env[key] = defaultValue;
      updated = true;
    }
  }
  
  // Write updated .env file
  if (updated || !envExists) {
    const envContent = stringifyEnvFile(env, !envExists);
    fs.writeFileSync(ENV_PATH, envContent, 'utf8');
    
    if (envExists) {
      console.log('üîÑ Updated existing .env file');
    } else {
      console.log('üìù Created new .env file');
    }
  } else {
    console.log('‚úÖ Environment configuration is already complete');
  }
  
  // Validate configuration
  console.log('\nüîç Validating configuration...');
  
  const validationResults = {
    'JWT Secret': isSecureJWTSecret(env.JWT_SECRET) ? '‚úÖ Secure' : '‚ùå Insecure',
    'Database Config': (env.DB_HOST && env.DB_PORT && env.DB_USER && env.DB_NAME) ? '‚úÖ Complete' : '‚ö†Ô∏è  Incomplete',
    'Port': env.PORT ? '‚úÖ Set' : '‚ùå Missing',
    'Node Environment': env.NODE_ENV ? '‚úÖ Set' : '‚ùå Missing'
  };
  
  for (const [check, result] of Object.entries(validationResults)) {
    console.log(`  ${check}: ${result}`);
  }
  
  // Show warnings for placeholder values
  const warnings = [];
  if (env.TELEGRAM_BOT_TOKEN && env.TELEGRAM_BOT_TOKEN.includes('your_telegram_bot_token_here')) {
    warnings.push('‚ö†Ô∏è  TELEGRAM_BOT_TOKEN still contains placeholder value');
  }
  if (env.DB_PASSWORD === 'postgres') {
    warnings.push('‚ö†Ô∏è  Using default database password - consider changing for security');
  }
  
  if (warnings.length > 0) {
    console.log('\n‚ö†Ô∏è  Warnings:');
    warnings.forEach(warning => console.log(`  ${warning}`));
  }
  
  console.log('\n‚úÖ Environment initialization completed!');
  console.log(`üìç Configuration saved to: ${ENV_PATH}`);
  
  return env;
}

// Run initialization if called directly
if (require.main === module) {
  initEnv().catch(error => {
    console.error('‚ùå Environment initialization failed:', error);
    process.exit(1);
  });
}

module.exports = { initEnv, generateJWTSecret, generateSessionSecret, isSecureJWTSecret };